```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

В подсистему загрузчиков классов (_ClassLoading_) приходит команда на загрузку класса _JvmComprehension_ и необходимых для работы программы системных классов в _Metaspace_. \
Дальше работает подстема _ClassLoading_: запрос поступает в _Application ClassLoader_, он делегирует запрос _Platform ClassLoader_, который, в свою очередь, делегирует запрос в _Bootstrap ClassLoader_. Все найденные классы загружаются. 
***
При вызове метода _main_ в стэке создается фрейм. 
1. Выделяется место для переменной в стэке и и сохраняется ее значение "1". 
2. Создается новый объект. Оператор _new_ выделит место в куче. Дальше срабатывает конструктор класса _object_ и в куче инициализируются данные объекта. В стэке создается переменная "о" и ей присваивается ссылка на объект из кучи.
3. Аналогично создается объект "ii" типа _integer_ в куче со значением 2, в стэке сохраняется ссылка на объект.
4. Вызов метода _prinAll_. В стэке создается новый фрейм. На объекты _i, o, ii_ создаются новые ссылки в созданном фрэйме.
5. Создается объект _uselessVar_ типа _integer_ (аналогично п.2-3), в кучу сохраняется значение 700.
6. Для метода будет создан новый фрейм, в который будут переданы ссылки на объекты _i, o, ii_. Команда _o.toString_ создает новую строку. Результат выведется в консоль.
7. Для метода будет создан новый фрейм. Результат выведется в консоль.

При создании нового фрейма, данные предыдущего фрейма становятся недоступны.
***
Сборщик мусора срабатывает автоматически в течении всего времени работы программы. \
Объекты, которые больше не используются, определяются при помощи обхода графа достижимых объектов. Недостижимые объекты удаляются. Достижимые объекты группируются по времени жизни и распологаются в куче непрерывно. \
Во время сборки мусора работа программы приостанавливается.

